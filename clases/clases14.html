<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/main.css">
    <title>Clase 14: PROMISES & ASYNC</title>
</head>

<body>
<div class="bg1">
    <header id="header__clases">
        <nav class="clases__nav">
            <figure class="nav__logo">
                <a href="../index.html"><img class="logo__img" src="../img/jslogo.webp" alt=""></a>
            </figure>
            <ul class="nav__list">
                <li class="nav__item"><a class="nav__link" href="../index.html">Inicio</a></li>
                <li class="nav__item"><a class="nav__link nav__botonAnterior" href="">Clase Anterior</a></li>
                <li class="nav__item"><a class="nav__link nav__botonSiguiente" href="">Clase Siguiente</a></li>
            </ul>
        </nav>
    </header>
</div>
        
<main id="clases__main">
    <div class="bg2">
        <section class="clases__anotaciones">
            <h2 class="clases__title">Anotaciones:</h2>
            <article class="article__anotaciones">
                <article class="anotaciones5__temario">
                    <h3 class="temario__title">Temario de la clase:</h3>
                    <ul class="temario__list">
                        <li class="temario__item">Asincronias</li>
                        <li class="temario__item">Promesas</li>
                    </ul>
                </article>

                <article class="clase__tema clase14__tema1">
                    <div class="div--column">
                        <h4>ASYNC: Asincronismo</h4>
                        <p>Javascript es un lenguaje asíncrono, lo que significa que su forma de procesar algoritmos se basa en una cola de eventos, donde cada evento se ejecuta en el orden en que llega, y no necesariamente en el orden en que se llama. El objetivo de esta sección es entender cómo funciona el asincronismo en Javascript y cómo utilizarlo para mejorar el rendimiento y la experiencia del usuario.</p>
                    </div>
                    <div class="div--column">
                        <p><span>Call Stack y Sincronía</span></p>
                        <p>El Call Stack es la pila de ejecución de Javascript, es una estructura de datos LIFO (Last in, first out) que almacena las funciones y métodos que están siendo ejecutados. El Javascript siempre procesa el call stack de forma síncrona, es decir, una función o método debe ser completamente ejecutado antes de que se pueda continuar con la siguiente.</p>
                        <img src="../img/clase14/ejemplo1.png" alt="">
                        <p>En el ejemplo anterior el orden de ejecucion sera totalmente sincrono, o sea se respeta el orden de las sentencias</p>
                    </div>
                    <div class="div--column">
                        <p><span>setTimeout y clearTimeout</span></p>
                        <p>setTimeout() es un método asíncrono que permite ejecutar un callback después de un tiempo específico en milisegundos. El método recibe dos argumentos obligatorios: el callback y el tiempo en milisegundos. Por otro lado, clearTimeout() permite interrumpir el proceso asíncrono setTimeout.</p>
                        <img src="../img/clase14/ejemplo2.png" alt="">
                    </div>
                    <div class="div--column">
                        <p><span>setInterval y clearInterval</span></p>
                        <p>setInterval() es un método asíncrono que permite ejecutar un callback cada cierto tiempo especificado en milisegundos, en un loop. Por otro lado, clearInterval() permite interrumpir el proceso asíncrono setInterval.</p>
                        <img src="../img/clase14/ejemplo3.png" alt="">
                    </div>
                </article>

                <article class="clase__tema clase14__tema2">
                   <div class="div--column">
                    <h4>PROMISES: Promesas</h4>
                    <p>Las promesas en Javascript representan un evento a futuro, es decir, una operación que se realiza de manera asíncrona y cuya finalización o resultado se desconoce en el momento de su creación. Una promesa tiene tres estados posibles: pending, fulfilled y rejected. Una vez que se ha cumplido o fallado una promesa, ya no puede cambiar de estado. En este documento, vamos a explorar varios métodos y conceptos relacionados con las promesas en Javascript.</p>
                    <p><span>Creacion de promesas</span></p>
                    <p>Para crear una promesa en Javascript se utiliza el constructor new Promise(executor), donde el parámetro executor es una función que recibe dos callbacks: resolve y reject. La función executor se ejecuta de forma inmediata al crear la promesa, y su objetivo es definir el comportamiento de la promesa en caso de éxito (resolve) o fracaso (reject).</p>
                    <img src="../img/clase14/ejemplo4.png" alt="">
                   </div>
                   <div class="div--colum">
                    <p><span>Utilizando promesas</span></p>
                    <p>Una vez creada una promesa, para acceder a su resultado se utilizan los métodos then, catch, y finally. El método then se utiliza para manejar el resultado de una promesa cumplida (resolve), y permite acceder al valor retornado por su callback. El método catch se utiliza para manejar el resultado de una promesa fallida (reject), y permite acceder al valor retornado por su callback. Por último, el método finally se ejecuta independientemente del resultado de la promesa, y se utiliza para realizar tareas de limpieza o notificaciones.</p>
                    <img src="../img/clase14/ejemplo5.png" alt="">
                   </div>
                   <div class="div--columm">
                    <p><span>Promesas anidadas y encadenadas</span></p>
                    <p>En algunas situaciones, es necesario realizar múltiples operaciones asíncronas de forma secuencial o en paralelo. En estos casos, es posible anidar varias promesas mediante el uso de then y catch, o encadenar varias promesas mediante el retorno de una nueva promesa en el callback de then o catch.</p>
                   </div>
                </article>
        
            </article>
        </section>
    </div>
</main>
        
<div class="bg1">
    <footer id="js__footer">
        <div class="footer__imgs">
            <img class="img1" src="../img/jslogo.webp" alt="">
            <a target="_blank" href="https://www.coderhouse.com/"><img class="img2" src="../img/logos_coderhouse.png" alt=""></a>
        </div>
        <div class="footer__descrip">
            <p>Anotaciones, resumenes, consignas y practicas desarrolladas en el curso de JavaScript dictado en Coderhouse.</p> 
        </div>
    </footer>
</div>


    <script src="../js/clase14.js"></script>
    <script src="../js/main.js"></script>
</body>
</html>